// generated by AvatarBlock
#include <Arduino.h>
#include <Sentry.h>
#include <Wire.h>
#include "LegControl_task.h"
#include "SCServo.h"
#include <PS4Controller.h>
#include "esp_bt_main.h"
#include "esp_bt_device.h"
#include "esp_gap_bt_api.h"
#include "esp_err.h"
typedef Sentry2 Sentry;
#define VISION_TYPE Sentry::kVisionBlob
Sentry sentry;
sentry_object_t param = {0};
uint8_t w, h, x, y, z;
TaskHandle_t myTaskHandle;
int posX, posY, posZ;

bool taskFlag = 0;
void myTask(void *parameter)
{
  while (1)
  {
    if (sentry.GetValue(VISION_TYPE, kStatus))
    {
      w = sentry.GetValue(VISION_TYPE, kWidthValue, 1);
      h = sentry.GetValue(VISION_TYPE, kHeightValue, 1);
      x = sentry.GetValue(VISION_TYPE, kXValue, 1);
      y = sentry.GetValue(VISION_TYPE, kYValue, 1);
      z = 1;
    }
    else
    {
      w = 0;
      h = 0;
      x = 0;
      y = 0;
      z = 0;
    }
    if (taskFlag == 1)
    {
      vTaskDelay(1000);
      w = 0;
      h = 0;
      x = 0;
      y = 0;
      z = 0;
      taskFlag = 0;
    }
  }
}
UserMpu Mpu;
// 全局变量
Gait_prg gait_prg; // 步态规划
SCSCL arm;
Hexapod hexapod(arm, gait_prg);                            // 机器人结构体
uint32_t round_time;                                       // 回合时间
static uint32_t code_time_start, code_time_end, code_time; // 用于计算程序运行时间，保证程序隔一段时间跑一遍
uint32_t preTime;
uint32_t curTime;
// 函数
void hexapodMove()
{
  code_time_start = millis(); // 获取当前时间
  if (hexapod.velocity.omega >= 0)
    LegControl_round = (++LegControl_round) % N_POINTS; // 控制回合自增长
  else
  {
    if (LegControl_round == 0)
      LegControl_round = N_POINTS - 1;
    else
      LegControl_round--;
  }
  /*步态控制*/
  gait_prg.CEN_and_pace_cal();
  gait_prg.gait_proggraming();
  /*开始移动*/
  round_time = gait_prg.get_pace_time() / N_POINTS;
  hexapod.move(round_time);
  // delay(round_time);
  // 计算程序运行时间
  code_time_end = millis();                    // 获取当前时间
  code_time = code_time_end - code_time_start; // 做差获取程序运行时间（8ms）
  if (code_time < round_time)
  {
    delay(round_time - code_time); // 保证程序执行周期等于回合时间
  }
  else
    delay(1); // 至少延时1ms
}

void hexapodStop()
{
  for (int i = 0; i < 10; i++)
  {
    hexapod.body_angle_and_pos_zero(); // 停止
    hexapod.velocity_cal(0, 0, 0);
    hexapod.body_angle_cal(0, 0, 0);
    hexapod.body_position_cal(0, 0, 0);
    hexapodMove();
  }
}

void findBlock(uint8_t xMin, uint8_t xMax, uint8_t yMin, uint8_t yMax)
{
  while (!(x < xMax && x > xMin && y < yMax && y > yMin))
  {
    int xVelocity = (x < xMin) ? -60 : (x > xMax) ? 60
                                                  : 0;
    int yVelocity = (y < yMin) ? 60 : (y > yMax) ? -60
                                                 : 0;
    hexapod.velocity_cal(xVelocity, yVelocity, 0);
    hexapodMove();
  }
}

void seekBlock(int x_min, int x_max, int y_min, int y_max)
{
  float posX = 1, posY = 1;
  int posZ = 1;
  uint32_t hour = millis();
  // 当接收到的数据不在特定范围内时，执行循环
  while (!(x < x_max && x > x_min && y < y_max && y > y_min))
  {
    // 限制posX和posY的值在-256到256之间
    value_limit(posX, -256, 256);
    value_limit(posY, -256, 256);
    // 根据接收到的xValue和yValue的值，更新posX和posY
    posX += (x < x_min) ? -4 : (x > x_max) ? 4
                                           : 0;
    posY += (y < y_min) ? 4 : (y > y_max) ? -4
                                          : 0;
    // 计算机器人的身体位置
    hexapod.body_position_cal(posX, posY, posZ);
    // 移动机器人
    hexapodMove();
    if (millis() - hour > 6000)
    {
      break;
    }
  }
}

void setup()
{
  PS4.begin("ba:ba:ca:ea:02:01");
  uint8_t pairedDeviceBtAddr[20][6];
  int count = esp_bt_gap_get_bond_device_num();
  esp_bt_gap_get_bond_device_list(&count, pairedDeviceBtAddr);
  for (int i = 0; i < count; i++)
  {
    esp_bt_gap_remove_bond_device(pairedDeviceBtAddr[i]);
  }
  sentry_err_t err = SENTRY_OK;
  Wire.begin();
  while (SENTRY_OK != sentry.begin(&Wire))
  {
    yield();
  }
  xTaskCreatePinnedToCore(myTask, "My Task", 4096, NULL, 1, &myTaskHandle, 1);
  sentry.SetParamNum(VISION_TYPE, 1);
  taskFlag = 1;
  param.width = 3;
  param.height = 4;
  param.label = 3;
  sentry.SetParam(VISION_TYPE, &param, 1);
  sentry.VisionBegin(VISION_TYPE);
  vTaskResume(myTaskHandle);
  Serial2.begin(1000000, SERIAL_8N1, 18, 4);
  Serial1.begin(1000000, SERIAL_8N1, 16, 5);
  // Serial.begin(115200);
  arm.pSerial = &Serial1;
  arm.pSerial2 = &Serial2;
  Mpu.mpu_Init();
  gait_prg.Init();
  delay(100);
  hexapod.Init(0);
  // hexapod.mode_select(1);
  // findBlock(60, 70, 70, 80);
  // hexapodStop();
  // hexapod.mode_select(3);
  // seekBlock(76, 80, 82, 86);
  // arm.servoMove(20, 240, 1000);
  // delay(3.5 * 1000);
  // arm.servoMove(20, 150, 1000);
  // delay(1 * 1000);
  // hexapodStop();
  hexapod.mode_select(3);
  posX=posY=posZ=0;
}
void loop()
{

  if (PS4.Up())
  {
    posY = posY + 3;
  }
  if (PS4.Down())
  {
    posY = posY - 3;
  }
  if (PS4.Left())
  {
    posX = posX - 3;
  }
  if (PS4.Right())
  {
    posX = posX + 3;
  }
  if (PS4.Square())
  {
    posZ = posZ + 3;
  }
  if (PS4.Cross())
  {
    posZ = posZ - 3;
  }
  hexapod.body_position_cal(posX, posY, posZ);
  // Mpu.mpu_cab();
  hexapodMove();
}